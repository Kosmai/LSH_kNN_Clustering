Κατακερματισμός και αναζήτηση για χρονοσειρές στη C++

Μέλη Ομάδας
-------------------------------------------------------------------------------------------------------------
Κωνσταντίνος Μαϊδάτσης (ΑΜ: 1115201800102)
Διονύσιος Μανιατάκος   (ΑΜ: 1115201800104)

Σύνδεσμος GitHub
-------------------------------------------------------------------------------------------------------------
https://github.com/Kosmai/LSH_kNN_Clustering
Για λόγους αποφυγής αντιγραφής το παραπάνω repository είναι ιδιωτικό προς το παρόν.

Σύντομη Περιγραφή
-------------------------------------------------------------------------------------------------------------
Το συγκεκριμένο πρόγραμμα στοχεύει στην εύρεση πλησιέστερων γειτόνων και στη συσταδοποίηση χρονοσειρών
αναπαριστώντας αυτές είτε ώς διανύσματα ή ως πολυγωνικές καμπύλες. Στην πρώτη περίπτωση χρησιμοποιείται
η μετρική L2 ενώ στη δεύτερη περίπτωση η μετρική Frechet (τόσο η διακριτή όσο και η συνεχής εκδοχή της).
Για  την εύρεση πλησιέστερων γειτόνων χρησιμοποιείται οι αλγόριθμος "Locality Sensitive Hashing" ("LSH"), 
ο αλγόριθμος τυχαίας προβολής στον υπερκύβο, αλλά και η προσέγγιση ωμής βίας. Για τη συσταδοποίηση (K-Means),
χρησιμοποιείται ο ακριβής αλγόριθμος "Lloyd" και η αντίστροφη ανάθεση μέσω Range Search, τόσο με τη χρήση
του "LSH" αλγορίθμου όσο και με τη χρήση του αλγορίθμου προβολής στον υπερκύβο. Το πρόγραμμα είναι υλοποιημένο
σε C++14. Για τον έλεγχο μονάδας (Unit Testing), χρησιμοποιείται το framework GoogleTest, ένα C++ framework
για αυτοματοποιημένο έλεγχο μονάδας που έχει αναπτυχθεί από τη Google. Γίνεται χρήση της βιβλιοθήκης "Fred"
για τον υπολογισμό της συνεχούς απόστασης Frechet (https://github.com/derohde/Fred).


Οδηγίες Μεταγλώττισης 
-------------------------------------------------------------------------------------------------------------

Για τη μεταγλώττιση του προγράμματος αρκεί να εκτελεστεί στον κεντρικό κατάλογο ("Time_Series_kNN_Clustering") 
η εντολή "make" η οποία, αξιοποιώντας το Makefile, δημιουργεί τρία εκτελέσιμα αρχεία, ένα για την εύρεση 
πλησιέστερων γειτόνων (search), ένα για τη συσταδοποίηση (cluster) και ένα για τον αυτοματοποιημένο έλεγχο μονάδας
(testing). Προϋπόθεση για την επιτυχή μεταγλώττιση είναι να είναι εγκατεστημένος ο μεταγλωττιστής g++ αλλά
και η βιβλιοθήκη GoogleTest. Για την εγκατάσταση της συγκεκριμένης βιβλιοθήκης αρκεί να εκτελεστεί η παρακάτω
εντολή στη γραμμή εντολών (debian):

-> sudo apt-get install libgtest-dev

Σε περίπτωση που δεν είναι επιθυμητή η εγκατάσταση της συγκεκριμένης βιβλιοθήκης (και συνεπώς η παραγωγή 
του εκτελέσιμου testing), αρκεί να εκτελεστεί η εντολή "make notests".

Οι οδηγίες εκτέλεσης παρατίθενται παρακάτω.

Οδηγίες Εκτέλεσης & Χρήσης
-------------------------------------------------------------------------------------------------------------
->	Για την εύρεση πλησιέστερων γειτόνων αρκεί να εκτελεστεί το εκτελέσιμο search, που έχει παραχθεί με τη
	μεταγλώττιση, με τα παρακάτω ορίσματα:

	./search -i <input file> -q <query file> -k <int> -L <int> -M <int> -probes <int> -o <output file> -algorithm <LSH/Hypercube/Frechet> -metric <discrete/continuous> -delta <double> -disableBF <optional> -w <double>

	Το προαιρετικό όρισμα -disableBF εντάχθηκε προκειμένου να αποφευχθεί ο χρόνοβόρος υπολογισμός της προσέγγισης ωμής βίας,
	κυρίως κατά τη χρήση της συνεχούς εκδοχής της μετρικής Frechet.

	Για την ευκολία στη χρήση, υπάρχουν προκαθορισμένα ορίσματα, με αποτέλεσμα να είναι δυνατή η παράλειψη
	των περισσότερων παραμέτρων:

	Παράδειγμα εκτέλεσης:
	./search -i datasets/nasd_input.csv -q datasets/nasd_query.csv -o search.out -algorithm Frechet -metric discrete


->	Για τη συσταδοποίηση χρονοσειρών αρκεί να εκτελεστεί το αρχείο "cluster" που έχει παραχθεί από τη
	μεταγλώττιση με τα παρακάτω ορίσματα:

	./cluster -i <input file> -c <configuration file> -o <output file> -update <Mean Frechet/Mean Vector> -assignment <Classic/LSH/Hypercube/LSH_Frechet> -complete <optional> -silhouette <optional>

	Παράδειγμα εκτέλεσης:
	./cluster -i datasets/nasd_input.csv -c config/cluster.conf -o cluster.out -update Mean Frechet -assignment LSH_Frechet -complete -silhouette

	Είναι απαραίτητο να υπάρχει ένα αρχείο configuration με την ακόλουθη μορφή:

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	number_of_clusters: <int>
	number_of_vector_hash_tables: <int>
	number_of_vector_hash_functions: <int>
	max_number_M_hypercube: <int>
	number_of_hypercube_dimensions: <int>
	number_of_probes: <int>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Στις εντολές εκτέλεσης είναι εφικτό τα ορίσματα να δίνονται με διαφορετική σειρά. Αν δε δοθεί κάποιο όρισμα
χρησιμοποιείται η default τιμή ή ζητείται από τον χρήστη (στην περίπτωση των αρχείων του συνόλου δεδομένων,
του αρχείου ερωτημάτων και του αρχείου εξόδου).


Περιγραφή Καταλόγων & Modules
-------------------------------------------------------------------------------------------------------------
Στον κατάλογο του προγράμματος υπάρχουν τέσσερις υποκατάλογοι. Ο κατάλογος "src" περιλαμβάνει όλα τα αρχεία
πηγαίου κώδικα και ο κατάλογος "inc" τα αρχεία επικεφαλίδων. Ο κατάλογος config περιλαμβάνει ένα δοκιμαστικό
configuration αρχείο για το clustering. Ο κατάλογος datasets εξυπηρετεί την τοθοποθέτηση των συνόλων δεδομένων.
Υπάρχουν τρία αρχεία με main συναρτήσεις, ένα για την αναζήτηση πλησιέστερων γειτόνων ("search"), ένα για τη
συσταδοποίηση ("cluster") και ένα για τον έλεγχο ("testing"). Ακολουθεί περιγραφή των modules του κώδικα:

->	LSH.cpp/LSH.hpp

	Στα αρχεία αυτά υλοποιείται η κλάση LSH η οποία περιλαμβάνει ότι ειναι απαραίτητο για την εύρεση πλησιέστερων 
	γειτόνων με τον αλγόριθμο "Locality Sensitive Hashing". Έχει ως μέλη τις παραμέτρους του αλγορίθμου, έναν 
	πίνακα πινάκων κατακερματισμού, ένα σύνολο συναρτήσεων κατακερματισμού g, μία λίστα απο δείκτες σε 
	σημεία (τα οποία αποτελούν το σύνολο δεδομένων), μία λίστα από "γείτονες" που έχουν υπολογιστεί μέσω 
	του αλγορίθμου "LSH" και μία λίστα απο "γείτονες" που έχουν υπολογιστεί από εξαντλητική αναζήτηση. Οι 
	μέθοδοι της κλάσης περιλαμβάνουν, μεταξύ άλλων, την "calculateNN" η οποία δέχεται ως ορίσματα το σημείο 
	για το οποίο αναζητάμε γείτονες, τον αριθμό των πλησιέστερων γειτόνων που αναζητάμε, και r το μήκος της
	ακτίνας αναζήτησης. Η μέθοδος αυτή χρησιμοποιεί την μέθοδο "LSHSearch" στην οποία ουσιαστικά ύλοποιείται 
	ο βασικός αλγόριθμος, την bruteForceSearch στην οποία υλοποιείται ο εξαντλητικός αλγόριθμος και την 
	"displayResults" η οποία εκτυπώνει τα αποτελέσματα στο αρχείο εξόδου.  Επίσης, υπάρχει η μέθοδος "addPoint"
	η οποία δέχεται ως όρισμα δείκτη σε ένα σημείο το οποίο πρόκειται να εισαχθεί στο σύνολο δεδομένων. Στην 
	κλάση υπάρχει, η μέθοδος "getNearestByR" η οποία χρησιμοποιείται στη συσταδοποίηση. Τέλος, υπάρχει η στατική 
	μέθοδος "calculateW" η οποία χρησιμοποιείται για τον υπολογισμό της παραμέτρου w δεδομένου του συνόλου δεδομένων.

->	hypercube.cpp/hypercube.hpp

	Στα αρχεία αυτά υλοποιείται η κλάση Hypercube η οποία λειτουργεί με παρόμοιο τρόπο με την κλάση LSH, με τις
	απαραίτητες διαφοροποιήσεις ώστε να υλοποιείται ο αλγόριθμος προβολής στον υπερκύβο. Μία απο τις σημαντικές
	διαφοροποιήσεις είναι οτι χρησιμοποιείται διαφορετικό είδος συναρτήσεων κατακερματισμού (hashFunctionF). 

->	kmeans.cpp/kmeans.hpp

	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Kmeans η οποία περιλαμβάνει τα απαραίτητα μέλη και μεθόδους
	για τη συσταδοποίηση. Πιο συγκεκριμένα περιέχει ένα πίνακα με στιγμιότυπα της κλάσης Cluster και μεταξύ άλλων
	μεθόδους για την συσταδοποίηση με κάθε έναν από τους αλγορίθμους που ζητούνται (Lloyd, Reverse Assignment
	με LSH / Hypercube) 

->	point.cpp/point.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Point η οποία αναπαριστά ένα σημείο, κάνοντας χρήση της δομής
	vector της STL βιβλιοθήκης. Η κλάση περιλαμβάνει επίσης ως μέλος το id του σημείου καθώς και 2 ακόμα μέλη που 
	χρησιμοποιούνται στη συσταδοποίηση. Στις μεθόδους της κλάσης περιλαμβάνονται, μεταξύ άλλων, η μέθοδος η 
	οποία επιστρέφει την απόσταση του σημείου από ένα άλλο χρησιμοποιώντας τη μετρική L2. Η κλάση έχει ως
	μέλος και έναν δείκτη σε χρονοσειρά, από την οποία έχει προέλθει (μέσω διανυσματοποίησης). Αν το σημείο
	δεν έχει προέλθει από χρονοσειρά, τότε ο δείκτης αυτός είναι nullptr.

->	timeSeries.cpp/timeSeries.hpp

	Στα συγκεκριμένα αρχεία βρίσκεται η κλάση TimeSeries η οποία αναπαριστά μία χρονοσειρά ως μία πολυγωνική
	καμπύλη. Έχει μια συλλογή από παρατηρήσεις (observations) στην οποία διατηρούνται ζευγάρια χρονικής στιγμής
	και τιμής της χρονοσειράς. Υπάρχουν μέθοδοι που χρησιμοποιούνται για την προβολή σε πλέγμα, για 
	προεπεξεργασία (filtering) και για υπολογισμό της απόστασης Frechet, τόσο για τη διακριτή όσο και για τη 
	συνεχή προσέγγιση. Για τη συνεχή προσέγγιση χρησιμοποιείται η βιβλιοθήκη "Fred". Στα αρχεία αυτά υπάρχουν και 
	συναρτήσεις που είναι υπέυθυνες για την εύρεση της μέσης καμπύλης μεταξύ δύο και περισσότερων χρονοσειρών, 
	που χρησιμοποιείται στη συσταδοποίηση για τον επαναπροσδιορισμό του κεντροειδούς. Ο υπολογισμός της μέσης
	καμπύλης μεταξύ δύο χρονοσειρών γίνεται υπολογίζοντας τη βέλτιστη διαδρομή (traversal), και υπολογίζοντας
	το μέσο κάθε "λουριού". Επειδή η μέση καμπύλη που θα προκύψει είναι πιθανό να έχει μεγαλύτερες διαστάσεις,
	γίνεται μία δειγματοληψία με κατάλληλη συχνότητα δειγματοληψίας, ώστε η τελική καμπύλη όχι μόνο να έχει
	τις επιθυμητές διαστάσεις (όσες δηλαδή οι αρχικές καμπύλες) αλλά και να είναι όσο το δυνατόν πιο πιστή
	στην πραγματική μέση καμπύλη.

->	hashtable.cpp/hashtable.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η δομή δεδομένων ενός πίνακα κατακερματισμού η οποία χρησιμοποιείται 
	εκτενώς στο πρόγραμμα. Γίνεται χρήση της λίστας που περιλαμβάνεται στη βιβλιοθήκη STL.

->	randGen.cpp/randGen.hpp

	Στα συγκεκριμένα αρχεία βρίσκονται συναρτήσεις η οποίες επιστρέφουν τυχαίους αριθμούς με βάση την κανονική
	και την ομοιόμορφη κατανομή.

->	hashFunction*.cpp/hashFunction*.cpp
	
	Στα συγκεκριμένα αρχεία βρίσκονται συναρτήσεις η οποίες λειτουργούν ως συναρτήσεις κατακερματισμού για
	τους αλγορίθμους "LSH" και τυχαίας προβολής σε υπερκύβο.

->	readInput.cpp/readInput.hpp

	Στα αρχεία αυτά βρίσκονται συναρτήσεις οι οποίες αφορούν την ανάγνωση των ορισμάτων της γραμμής εντολών,
	την ανάγνωση των αρχείων με τα σύνολα δεδομένων και την ανάγνωση του configuration αρχείου, στην περίπτωση
	της συσταδοποίησης.

->	hamming.cpp/hamming.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Hamming η οποία χρησιμοποιείται για την αναζήτηση γειτονικών
	κορυφών στον αλγόριθμο τυχαίας προβολής στον υπερκύβο.

->	cluster.cpp/cluster.hpp

	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Cluster η οποία αναπαριστά μία συστάδα διατηρώντας μία λίστα
	με δείκτες στα σημεία που έχουν ανατεθεί στη συστάδα αυτή και τη θέση του κεντροειδούς της συστάδας. Στις
	μεθόδους υπάρχει, μεταξύ άλλων, συνάρτηση για τον επαναυπολογισμό των συντεταγμένων του κεντροδειδούς.

->	searchUtils.cpp/searchUtils.hpp/clusteringUtils.cpp/clusteringUtils.hpp

	Στα συγκεκριμένα αρχεία υπάρχουν διάφορες βοηθητικές συναρτήσεις που χρησιμοποιούνται από τις 
	αντίστοιχες main συναρτήσεις με σκοπό τον πιο αναγνώσιμο κώδικα.

->	fred
	
	Στον συγκεκριμένο κατάλογο βρίσκονται όλα τα απαιραίτητα αρχεία της βιβλιοθήκης "Fred", που χρησιμοποιούνται
	για τον υπολογισμό της συνεχούς απόστασης Frechet. Έχουν αφαιρεθεί μικρά τμήματα κώδικα που αφορούν
	τη δημιουργία διεπαφής για Python (pybind) ώστε να μην είναι απαραίτητη η εγκατάσταση της συγκεκριμένης
	βιβλιοθήκης.

Παραδοχές
-------------------------------------------------------------------------------------------------------------
Ο υπολογισμός της συνεχούς απόστασης Frechet ο οποίος υλοιείται από τη βιβλιοθήκη "Fred" είναι αρκετά χρονοβόρος.
Ως εκ τούτου, είναι πιθανό τα ερωτήματα να είναι αρκετά χρονοβόρα, ιδιαίτερα αν στο bucket αναζήτησης έχουν
συσσωρευθεί πολλά σημεία.

Ως κριτήριο διακοπής των επαναλήψεων στον kmeans έχει οριστεί μέγιστος αριθμός επαναλήψεων (5). Η επιλογή
αυτή έγινε αφού παρατηρήθηκε, ότι οι επαναλήψεις αυτές συνήθως αρκούν ενώ περισσότερες επαναλήψεις θα ήταν 
αρκετά χρονοβόρες.

Hypercube: k<30 Οι διαστάσεις προβολής στον υπερκύβο πρέπει να είναι μικρότερες από 30 λόγω φυσικών περιορισμών
υλικού. Επιπροσθέτως κάτι τέτοιο έρχεται αντίθετο στην λογική του υπερκύβου, που γενικά προβάλει σε χαμηλές
διαστάσεις (τάξης log_2(N) για N διαστάσεις).

Η μέγιστη ακτίνα R κατά το reverse assignment στη συσταδοποίηση έχει οριστεί ως σταθερά στο αρχείο 
clusterMain.cpp και πιθανώς να χρειαστεί τροποποίηση για δεδομένα με πολύ μεγάλες αποστάσεις.

Η δομή των αρχείων εισόδου πρέπει να ακολουθεί αυστηρά τη δομή των αρχείων που δόθηκαν.

Τα ονόματα των αρχείων εξόδου που δίνονται στο πρόγραμμα πρέπει να έχουν ονόματα που διαφέρουν από οποιοδήποτε
υπάρχον αρχείο πηγαίου κώδικα/επικεφαλίδας/binary ώστε να αποφεύγεται η αντικατάσταση τους.

Ο χρόνος αρχικοποίησης των δομών που χρησιμοποιούνται στο LSH αλλά και στο Hypercube δεν μετριέται, καθώς
ο χρόνος που μας ενδιαφέρει είναι αυτός της εκτέλεσης των ερωτημάτων. Σε ένα πραγματικό
σενάριο η αρχικοποίηση γίνεται μία φορά ενώ τα ερωτήματα μπορούν να γίνονται συνεχώς. Αντίθετα στο 
clustering μετριέται ο συνολικός χρόνος (συμπεριλαμβανομένου της αρχικοποίησης της εκάστοτε δομής), διότι
η δημιουργία των συστάδων αποτελεί το κεντρικό ζητούμενο.

Ο υπολογισμός της σιλουέτας μπορεί να είναι αρκετά χρονοβόρος, ανάλογα με το πλήθος των στοιχείων του συνόλου
δεδομένων, λόγω του τρόπου που υπολογίζεται η συγκεκριμένη μετρική. Για τον λόγο αυτό, είναι δυνατόν να
γίνει ανάγνωση του αρχείου εξόδου πριν τον υπολογισμό της σιλουέτας, ώστε να μπορεί ο χρήστης να δει τα
αποτελέσματα που έχουν ήδη εκτυπωθεί.

Σχόλια
-------------------------------------------------------------------------------------------------------------
Αρχικά, παρατηρείται ότι η αναζήτηση καθώς και η συσταδοποίηση με αναπαράσταση ως διάνυσμα (L2) είναι αρκετά
πιο αποδοτική όσον αφορά το χρόνο. Αντίθετα, η αναπαράσταση ως πολυγωνική καμπύλη (Frechet) οδηγεί σε πολύ
ψηλότερους χρόνους. Παρόλαυτά, η δεύτερη προσέγγιση είναι ένας πιο κατάλληλος τρόπος να αναπαριστούμε και να
συγκρίνουμε χρονοσειρές.

Σχετικά με την διανυσματική προσσέγγιση (L2), η ωμή βία δεν είναι πολύ πιο αργή από τους προσσεγγιστικούς
αλγορίθμους, καθώς το σύνολο δεδομένων είναι αρκετά μικρό. Στην αναπαράσταση με Frechet όμως υπάρχει εμφανής
διαφορά αφού ο υπολογισμός κάθε επιπλέον απόστασης Frechet είναι χρονοβόρος, ειδικά της συνεχούς εκδοχής.
Για τον λόγο αυτό και οι προσσεγγιστικοί αλγόριθμοι έχουν πολύ μεγάλο πλεονέκτημα στην συγκεκριμένη περίπτωση.

Εάν το σύνολο δεδομένων είναι μικρό, όπως στην περίπτωση μας, υπάρχει περίπτωση να είναι αρκετά αραιός ο
πίνακας κατακερματισμού (LSH) και να υπάρχουν ερωτήματα για τα οποία δεν μπορούμε να βρούμε κάποιο
κοντινό γείτονα.

Συμπεριλαμβάνονται ενδεικτικά κάποια από τα αρχεία εξόδου που χρησιμοποιήθηκαν για την εξαγωγή
των ανωτέρω συμπερασμάτων (στο φάκελο sample_outputs)