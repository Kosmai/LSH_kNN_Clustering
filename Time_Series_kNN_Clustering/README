Κατακερματισμός και αναζήτηση για χρονοσειρές στη C++

Μέλη Ομάδας
-------------------------------------------------------------------------------------------------------------
Κωνσταντίνος Μαϊδάτσης (ΑΜ: 1115201800102)
Διονύσιος Μανιατάκος   (ΑΜ: 1115201800104)

Σύνδεσμος GitHub
-------------------------------------------------------------------------------------------------------------
https://github.com/Kosmai/LSH_kNN_Clustering
Για λόγους αποφυγής αντιγραφής το παραπάνω repository είναι ιδιωτικό προς το παρόν.

Σύντομη Περιγραφή
-------------------------------------------------------------------------------------------------------------
Το συγκεκριμένο πρόγραμμα στοχεύσει στην εύρεση πλησιέστερων γειτόνων και στη συσταδοποίηση χρονοσειρών
αναπαριστώντας αυτές είτε ώς διανύσματα ή ως πολυγωνικές καμπύλες. Στην πρώτη περίπτωση χρησιμοποιείται
η μετρική L2 ενώ στη δεύτερη περίπτωση η μετρική Frechet (τόσο η διακριτή όσο και η συνεχής εκδοχή της).
Για  την εύρεση πλησιέστερων γειτόνων χρησιμοποιείται οι αλγόριθμος "Locality Sensitive Hashing" ("LSH"), 
ο αλγόριθμος τυχαίας προβολής στον υπερκύβο, αλλά και η προσέγγιση ωμής βίας. Για τη συσταδοποίηση (K-Means),
χρησιμοποιείται ο ακριβής αλγόριθμος "Lloyd" και η αντίστροφη ανάθεση μέσω Range Search, τόσο με τη χρήση
του "LSH" αλγορίθμου όσο και με τη χρήση του αλγορίθμου προβολής στον υπερκύβο. Το πρόγραμμα είναι υλοποιημένο
σε C++11. Για τον έλεγχο μονάδας (Unit Testing), χρησιμοποιείται το framework GoogleTest, ένα C++ framework
για αυτοματοποιημένο έλεγχο μονάδας που έχει αναπτυχθεί από τη Google. Γίνεται χρήση της βιβλιοθήκης "Fred"
γθα τον υπολογισμό της συνεχούς απόστασης Frechet (https://github.com/derohde/Fred).


Οδηγίες Μεταγλώττισης 
-------------------------------------------------------------------------------------------------------------

Για τη μεταγλώττιση του προγράμματος αρκεί να εκτελεστεί στον κεντρικό κατάλογο ("Time_Series_kNN_Clustering") 
η εντολή "make" η οποία, αξιοποιώντας το Makefile, δημιουργεί τρία εκτελέσιμα αρχεία, ένα για την εύρεση 
πλησιέστερων γειτόνων (search), ένα για τη συσταδοποίηση (cluster) και ένα για τον αυτοματοποιημένο έλεγχο μονάδας
(testing). Προϋπόθεση για την επιτυχή μεταγλώττιση είναι να είναι εγκατεστημένος ο μεταγλωττιστής g++ αλλά
και η βιβλιοθήκη GoogleTest. Για την εγκατάσταση της συγκεκριμένης βιβλιοθήκης αρκεί να εκτελεστεί η παρακάτω
εντολή στη γραμμή εντολών:

-> sudo apt-get install libgtest-dev

Σε περίπτωση που δεν είναι επιθυμητή η εγκατάσταση της συγκεκριμένης βιβλιοθήκης (και συνεπώς η παραγωγή 
του εκτελέσιμου testing), αρκεί να αφαιρεθεί, από το makefile, η εξάρτηση "test" στον κανόνα "all" στη
γραμμή 8.

Οι οδηγίες εκτέλεσης παρατίθενται παρακάτω.

Οδηγίες Εκτέλεσης & Χρήσης
-------------------------------------------------------------------------------------------------------------
->	Για την εύρεση πλησιέστερων γειτόνων αρκεί να εκτελεστεί το εκτελέσιμο search, που έχει παραχθεί με τη
	μεταγλώττιση, με τα παρακάτω ορίσματα:

	./search -i <input file> -q <query file> -k <int> -L <int> -M <int> -probes <int> -o <output file> -algorithm <LSH/Hypercube/Frechet> -metric <discrete/continuous> -delta <double>


	Παράδειγμα εκτέλεσης:
	./search -i datasets/nasd_input.csv -q datasets/nasd_query.csv -k ? -L ? -M 1000 -probes 10 -o search.out -algorithm Frechet -metric discrete -delta 1 -disableBruteForce <optional>

	Το τελευταίο όρισμα εντάχθηκε προκειμένου να αποφευχθεί ο χρόνοβόρος υπολογισμός της προσέγγισης ωμής βίας,
	κυρίως κατά τη χρήση της συνεχούς εκδοχής της μετρικής Frechet.

	Για την ευκολία στη χρήση, υπάρχουν προκαθορισμένα ορίσματα, με αποτέλεσμα να είναι δυνατή η παράλειψη
	των περισσότερων παραμέτρων:

	Παράδειγμα εκτέλεσης:
	./search -i datasets/nasd_input.csv -q datasets/nasd_query.csv -o search.out -algorithm Frechet -metric discrete


->	Για τη συσταδοποίηση διανυσμάτων αρκεί να εκτελεστεί το αρχείο "cluster" που έχει παραχθεί από τη
	μεταγλώττιση με τα παρακάτω ορίσματα:

	./cluster -i <input file> -c <configuration file> -o <output file> -update <Mean Frechet/Mean Vector> -assignment <Classic/LSH/Hypercube/LSH_Frechet> -complete <optional> -silhouette <optional>

	Παράδειγμα εκτέλεσης:
	./cluster -i datasets/input_small_id -c config/cluster.conf -o cluster.out -update Mean Frechet -assignment LSH_Frechet -complete-silhouette

	Είναι απαραίτητο να υπάρχει ένα αρχείο configuration με την ακόλουθη μορφή:

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	number_of_clusters: <int>
	number_of_vector_hash_tables: <int>
	number_of_vector_hash_functions: <int>
	max_number_M_hypercube: <int>
	number_of_hypercube_dimensions: <int>
	number_of_probes: <int>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Στις εντολές εκτέλεσης είναι εφικτό τα ορίσματα να δίνονται με διαφορετική σειρά. Αν δε δοθεί κάποιο όρισμα
χρησιμοποιείται η default τιμή ή ζητείται από τον χρήστη (στην περίπτωση των αρχείων του συνόλου δεδομένων,
του αρχείου ερωτημάτων και του αρχείου εξόδου).


Περιγραφή Καταλόγων & Modules
-------------------------------------------------------------------------------------------------------------
Στον κατάλογο του προγράμματος υπάρχουν τέσσερις υποκατάλογοι. Ο κατάλογος "src" περιλαμβάνει όλα τα αρχεία
πηγαίου κώδικα και ο κατάλογος "inc" τα αρχεία επικεφαλίδων. Ο κατάλογος config περιλαμβάνει ένα δοκιμαστικό
configuration αρχείο για το clustering. Ο κατάλογος datasets εξυπηρετεί την τοθοποθέτηση των συνόλων δεδομένων.
Υπάρχουν τρία αρχεία με main συναρτήσεις, ένα για την αναζήτηση πλησιέστερων γειτόνων ("search"), ένα για τη
συσταδοποίηση ("cluster") και ένα για τον έλεγχο ("testing"). Ακολουθεί περιγραφή των modules του κώδικα:

->	LSH.cpp/LSH.hpp

	Στα αρχεία αυτά υλοποιείται η κλάση LSH η οποία περιλαμβάνει ότι ειναι απαραίτητο για την εύρεση πλησιέστερων 
	γειτόνων με τον αλγόριθμο "Locality Sensitive Hashing". Έχει ως μέλη τις παραμέτρους του αλγορίθμου, έναν 
	πίνακα πινάκων κατακερματισμού, ένα σύνολο συναρτήσεων κατακερματισμού g, μία λίστα απο δείκτες σε 
	σημεία (τα οποία αποτελούν το σύνολο δεδομένων), μία λίστα από "γείτονες" που έχουν υπολογιστεί μέσω 
	του αλγορίθμου "LSH" και μία λίστα απο "γείτονες" που έχουν υπολογιστεί από εξαντλητική αναζήτηση. Οι 
	μέθοδοι της κλάσης περιλαμβάνουν, μεταξύ άλλων, την "calculateNN" η οποία δέχεται ως ορίσματα το σημείο 
	για το οποίο αναζητάμε γείτονες, τον αριθμό των πλησιέστερων γειτόνων που αναζητάμε, και r το μήκος της
	ακτίνας αναζήτησης. Η μέθοδος αυτή χρησιμοποιεί την μέθοδο "LSHSearch" στην οποία ουσιαστικά ύλοποιείται 
	ο βασικός αλγόριθμος, την bruteForceSearch στην οποία υλοποιείται ο εξαντλητικός αλγόριθμος και την 
	"displayResults" η οποία εκτυπώνει τα αποτελέσματα στο αρχείο εξόδου.  Επίσης, υπάρχει η μέθοδος "addPoint"
	η οποία δέχεται ως όρισμα δείκτη σε ένα σημείο το οποίο πρόκειται να εισαχθεί στο σύνολο δεδομένων. Στην 
	κλάση υπάρχει, η μέθοδος "getNearestByR" η οποία χρησιμοποιείται στη συσταδοποίηση. Τέλος, υπάρχει η στατική 
	μέθοδος "calculateW" η οποία χρησιμοποιείται για τον υπολογισμό της παραμέτρου w δεδομένου του συνόλου δεδομένων.

->	hypercube.cpp/hypercube.hpp

	Στα αρχεία αυτά υλοποιείται η κλάση Hypercube η οποία λειτουργεί με παρόμοιο τρόπο με την κλάση LSH, με τις
	απαραίτητες διαφοροποιήσεις ώστε να υλοποιείται ο αλγόριθμος προβολής στον υπερκύβο. Μία απο τις σημαντικές
	διαφοροποιήσεις είναι οτι χρησιμοποιείται διαφορετικό είδος συναρτήσεων κατακερματισμού (hashFunctionF). 

->	kmeans.cpp/kmeans.hpp

	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Kmeans η οποία περιλαμβάνει τα απαραίτητα μέλη και μεθόδους
	για τη συσταδοποίηση. Πιο συγκεκριμένα περιέχει ένα πίνακα με στιγμιότυπα της κλάσης Cluster και μεταξύ άλλων
	μεθόδους για την συσταδοποίηση με κάθε έναν από τους αλγορίθμους που ζητούνται (Lloyd, Reverse Assignment
	με LSH / Hypercube) 

->	point.cpp/point.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Point η οποία αναπαριστά ένα σημείο, κάνοντας χρήση της δομής
	vector της STL βιβλιοθήκης. Η κλάση περιλαμβάνει επίσης ως μέλος το id του σημείου καθώς και 2 ακόμα μέλη που 
	χρησιμοποιούνται στη συσταδοποίηση. Στις μεθόδους της κλάσης περιλαμβάνονται, μεταξύ άλλων, η μέθοδος η 
	οποία επιστρέφει την απόσταση του σημείου από ένα άλλο χρησιμοποιώντας τη μετρική L2. Η κλάση έχει ως
	μέλος και έναν δείκτη σε χρονοσειρά, από την οποία έχει προέλθει (μέσω διανυσματοποίησης). Αν το σημείο
	δεν έχει προέλθει από χρονοσειρά, τότε ο δείκτης αυτός είναι nullptr.

->	timeSeries.cpp/timeSeries.hpp

	Στα συγκεκριμένα αρχεία βρίσκεται η κλάση TimeSeries η οποία αναπαριστά μία χρονοσειρά ως μία πολυγωνική
	καμπύλη. Έχει μια συλλογή από παρατηρήσεις (observations) στην οποία διατηρείται η μεταβλητή του χρόνου
	και κάθε τιμή της χρονοσειράς. Υπάρχουν μέθοδοι που χρησιμοποιούνται για την προβολή σε πλέγμα, για 
	προεπεξεργασία (filtering) και για υπολογισμό της απόστασης Frechet, τόσο τη διακριτή όσο και τη συνεχή
	προσέγγιση. Για τη συνεχή προσέγγιση χρησιμοποιείται η βιβλιοθήκη "Fred". Στα αρχεία αυτά υπάρχουν και 
	συναρτήσεις που είναι υπέυθυνες για την εύρεση της μέσης καμπύλης μεταξύ δύο και περισσότερων χρονοσειρών, 
	που χρησιμοποιείται στη συσταδοποίηση για τον επαναπροσδιορισμό του κεντροειδούς. Ο υπολογισμός της μέσης
	καμπύλης μεταξύ δύο χρονοσειρών γίνεται υπολογίζοντας τη βέλτιστη διαδρομή (traversal), και υπολογίζοντας
	το μέσο κάθε "λουριού". Επειδή η μέση καμπύλη που θα προκύψει είναι πιθανό να έχει μεγαλύτερες διαστάσεις,
	γίνεται μία δειγματοληψία με κατάλληλη συχνότητα δειγματοληψίας, ώστε η τελική καμπύλη όχι μόνο να έχει
	τις επιθυμητές διαστάσεις (όσες δηλαδή οι αρχικές καμπύλες) αλλά και να είναι όσο το δυνατόν πιο πιστή
	στην πραγματική μέση καμπύλη.

->	hashtable.cpp/hashtable.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η δομή δεδομένων ενός πίνακα κατακερματισμού η οποία χρησιμοποιείται 
	εκτενώς στο πρόγραμμα. Γίνεται χρήση της λίστας που περιλαμβάνεται στη βιβλιοθήκη STL.

->	randGen.cpp/randGen.hpp

	Στα συγκεκριμένα αρχεία βρίσκονται συναρτήσεις η οποίες επιστρέφουν τυχαίους αριθμούς με βάση την κανονική
	και την ομοιόμορφη κατανομή.

->	hashFunction*.cpp/hashFunction*.cpp
	
	Στα συγκεκριμένα αρχεία βρίσκονται συναρτήσεις η οποίες λειτουργούν ως συναρτήσεις κατακερματισμού για
	τους αλγορίθμους "LSH" και τυχαίας προβολής σε υπερκύβο.

->	readInput.cpp/readInput.hpp

	Στα αρχεία αυτά βρίσκονται συναρτήσεις οι οποίες αφορούν την ανάγνωση των ορισμάτων της γραμμής εντολών,
	την ανάγνωση των αρχείων με τα σύνολα δεδομένων και την ανάγνωση του configuration αρχείου, στην περίπτωση
	της συσταδοποίησης.

->	hamming.cpp/hamming.hpp
	
	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Hamming η οποία χρησιμοποιείται για την αναζήτηση γειτονικών
	κορυφών στον αλγόριθμο τυχαίας προβολής στον υπερκύβο.

->	cluster.cpp/cluster.hpp

	Στα συγκεκριμένα αρχεία υλοποιείται η κλάση Cluster η οποία αναπαριστά μία συστάδα διατηρώντας μία λίστα
	με δείκτες στα σημεία που έχουν ανατεθεί στη συστάδα αυτή και τη θέση του κεντροειδούς της συστάδας. Στις
	μεθόδους υπάρχει, μεταξύ άλλων, συνάρτηση για τον επαναυπολογισμό των συντεταγμένων του κεντροδειδούς.

->	searchUtils.cpp/searchUtils.hpp/clusteringUtils.cpp/clusteringUtils.hpp

	Στα συγκεκριμένα αρχεία υπάρχουν διάφορες βοηθητικές συναρτήσεις που χρησιμοποιούνται από τις 
	αντίστοιχες main συναρτήσεις με σκοπό τον πιο αναγνώσιμο κώδικα.

->	fred
	
	Στον συγκεκριμένο κατάλογο βρίσκονται όλα τα απαιραίτητα αρχεία της βιβλιοθήκης "Fred", που χρησιμοποιούνται
	για τον υπολογισμό της συνεχούς απόστασης Frechet. Έχουν αφαιρεθεί μικρά τμήματα κώδικα που αφορούν
	τη δημιουργία διεπαφής για Python (pybind) ώστε να μην είναι απαραίτητη η εγκατάσταση της συγκεκριμένης
	βιβλιοθήκης.

Παραδοχές
-------------------------------------------------------------------------------------------------------------
Hypercube: k<30 Οι διαστάσεις προβολής στον υπερκύβο πρέπει να είναι μικρότερες από 30 λόγω φυσικών περιορισμών
υλικού. Επιπροσθέτως κάτι τέτοιο έρχεται αντίθετο στην λογική του υπερκύβου, που γενικά προβάλει σε χαμηλές
διαστάσεις (τάξης log_2(N) για N διαστάσεις).

Η μέγιστη ακτίνα R κατά το reverse assignment στη συσταδοποίηση έχει οριστεί ως σταθερά (55000) στο αρχείο 
clusterMain.cpp και πιθανώς να χρειαστεί τροποποίηση για δεδομένα με πολύ μεγάλες αποστάσεις.

Η δομή των αρχείων εισόδου πρέπει να ακολουθεί αυστηρά τη δομή των αρχείων που δόθηκαν (κενό στο τέλος κάθε
γραμμής, ακριβώς μία κενή γραμμή στο τέλος, κτλπ)

Τα ονόματα των αρχείων εξόδου που δίνονται στο πρόγραμμα πρέπει να έχουν ονόματα που διαφέρουν από οποιοδήποτε
υπάρχον αρχείο πηγαίου κώδικα/επικεφαλίδας/binary ώστε να αποφεύγεται η αντικατάσταση τους.

Ο χρόνος αρχικοποίησης των δομών που χρησιμοποιούνται στο LSH αλλά και στο Hypercube δεν μετριέται, καθώς
ο χρόνος που μας ενδιαφέρει είναι αυτός της εκτέλεσης των ερωτημάτων (tLSH,tHypercube). Σε ένα πραγματικό
σενάριο η αρχικοποίηση γίνεται μία φορά ενώ τα ερωτήματα μπορούν να γίνονται συνεχώς. Αντίθετα στο 
clustering μετριέται ο συνολικός χρόνος (συμπεριλαμβανομένου της αρχικοποίησης της εκάστοτε δομής), διότι
η δημιουργία των συστάδων αποτελεί το κεντρικό ζητούμενο.

Ο υπολογισμός της σιλουέτας μπορεί να είναι αρκετά χρονοβόρος, ανάλογα με το πλήθος των στοιχείων του συνόλου
δεδομένων, λόγω του τρόπου που υπολογίζεται η συγκεκριμένη μετρική. Για τον λόγο αυτό, είναι δυνατόν να
γίνει ανάγνωση του αρχείου εξόδου πριν τον υπολογισμό της σιλουέτας, ώστε να μπορεί ο χρήστης να δει τα
αποτελέσματα που έχουν ήδη εκτυπωθεί.

Σχολιασμός Παραμετροποίησης
-------------------------------------------------------------------------------------------------------------
LSH:

->  Παράμετρος w

	Παρατηρούμε ότι για πολύ μεγάλες τιμές w ο αλγόριθμος LSH προσεγγίζει τα αποτελέσματα του αλγορίθμου
	ωμής βίας, καθώς όλο και περισσότερα σημεία προβάλονται στο ίδιο τμήμα της ευθείας και κατ'επέκταση
	στο ίδιο bucket. Αυτή η παρατήρηση επιβεβαίωνεται από τη θεωρία, σύμφωνα με την οποία το μήκος του
	κάθε τμήματος της ευθείας εξαρτάται άμεσα από το w. Προφανώς με πολύ μεγάλες τιμές της w, ο χρόνος
	αναζήτησης γίνεται ανάλογος του χρόνου της ωμής βίας αφού εξετάζουμε σχεδόν όλα τα σημεία του συνόλου
	δεδομένων. Από την άλλη, καθώς μειώνεται το w, μειώνεται ο χρόνος αναζήτησης, αφού εξετάζονται λιγότερα
	σημεία, υπάρχει όμως μείωση στην ακρίβεια των αποτελεσμάτων. Ως εκ τούτου, επιδιώκεται μία ενδιάμεση τιμή
	η οποία είναι ανάλογη της μέσης απόστασης μεταξύ των σημείων, ώστε να έχουμε σημαντική βελτίωση στο
	χρόνο εκτέλεσης, διατηρώντας υψηλή ακρίβεια.

->  Παράμετρος L

	Παρατηρούμε ότι καθώς μεγαλώνει ο αριθμός των πινάκων κατακερματισμού, αυξάνεται η ακρίβεια εύρεσης
	πλησιέστερου γείτονα αφού στην είναι πολύ πιο πιθανό να υπάρχει πραγματικά κοντινός γείτονας σε
	τουλάχιστον ένα από τους L πίνακες κατακερματισμού. Παράλληλα όμως, αυξάνεται και ο χρόνος αναζήτησης
	αφού εξετάζουμε περισσότερα σημεία. Για πολύ μικρές τιμές του L, παρατηρούμε σχετικά μεγαλύτερη 
	αστάθεια των αποτελεσμάτων, διότι επικρατεί η τυχαιοκρατική φύση του αλγορίθμου.

->  Παράμετρος k

	Παρατηρούμε ότι καθώς αυξάνεται το k είναι πιο δύσκολο δύο σημεία να έχουν το ίδιο hashing ID. Ως
	εκ τούτου, είναι πιο πιθανό δύο κοντινοί γείτονες να έχουν διαφορετικό ID. Προφανώς για μικρό k
	είναι εύκολο δύο σημεία να έχουν ίδιο ID χωρίς να είναι απαραίτητα κοντά, κυρίως για μεγάλα w, επειδή 
	υπάρχουν πολύ λίγες συναρτήσεις κατακερματισμού. Προφανώς στην πρώτη περίπτωση έχουμε καλύτερο χρόνο
	αφού εξετάζονται λιγότερα σημεία ως πιθανοί κοντινοί γείτονες.

Hypercube:

->  Παράμετρος w

	Αντίστοιχα με τον αλγόριθμο LSH.

->  Παράμετρος M / probes

	Προφανώς καθώς αυξάνετα το M και ο αριθμός των probes (κορυφών του υπερκύβου) που ελέγχονται, αυξάνεται
	τόσο η ακρίβεια όσο και ο χρόνος, καθώς εξετάζονται όλο και περισσότερα σημεία, προσεγγίζοντας τον
	αλγόριθμο ωμής βίας για M = N και αρκετά μεγάλο probes. Για πολύ μικρό M ή probes η ακρίβεια 
	μειώνεται κατα πολύ αφού δεν εξετάζονται σημεία που πιθανόν είναι αρκετά κοντινοί γείτονες. 

->  Παράμετρος k(d')

	Παρατηρούμε ότι για πολύ μεγάλο k = d' δηλαδή για προβολή σε πολλές διαστάσεις, είναι πιθανό να 
	είναι ασταθής η ακρίβεια γιατί μπορεί να μην ελεγχθούν κάποιες από τις γειτονικές κορυφές στις 
	οποίες έχουν προβληθεί κοντινοί γείτονες (για λογικό αριθμό probes/M). Αντίθετα, αν έχουμε πολύ
	μικρό k, η προβολή μπορεί να γίνει σε λίγες διαστάσεις, με αποτέλεσμα να ελένχονται σημεία που
	μπορεί να μην αποτελούν κοντινούς γείτονες και συνεπώς να αυξάνεται ο χρόνος αναζήτησης.

Clustering:

->	Αριθμός συστάδων

	Παρατηρούμε ότι ο βέλτιστος αριθμός συστάδων εξαρτάται από το σύνολο δεδομένων. Η μετρική silhouette
	αποτελεί ένα καλό τρόπο να εντοπίσουμε ένα κατάλληλο πλήθος συστάδων για τα δεδομένα μας.

->	Μέθοδοι

	Παρατηρούμε ότι ο αλγόριθμος Lloyd πετυχαίνει σταθερά καλά αποτελέσματα σύμφωνα με τα αποτελέσματα
	της silhouette, αλλά δεν πετυχαίνει πολύ χαμηλούς χρόνους για μεγάλα σύνολα δεδομένων.
	Ο αλγόριθμος LSH πετυχαίνει καλύτερους ή εφάμιλλους χρόνους με τις κατάλληλες παραμέτρους χωρίς 
	μεγάλη επίπτωση στα αποτελέσματα της silhouette. Επομένως είναι μια πολύ καλή επιλογή αν το
	σύνολο δεδομένων είναι πολύ μεγάλο. Παρόλαυτα λόγω της πιθανοκρατικής φύσης του αλγορίθμου,
	υπάρχει πιθανότητα κάποια σημεία να μην ανατεθούν σε κάποια συστάδα, και να ανατεθούν στο
	τέλος του αλγορίθμου. Αυτό μπορεί να προκαλέσει μη βέλτιστη συσταδοποίηση, ανάλογα με την
	αρχικοποίηση των κεντροειδών. Τέλος ο αλγόριθμος του υπερκύβου συνήθως πετυχαίνει χαμηλότερους
	χρόνους, αλλά είναι πιο πιθανό να μείνουν πολλά σημεία χωρίς ανάθεση ή να ανατεθούν σε
	μακρινούς κεντροειδείς, ειδικότερα για μη βέλτιστη επιλογή παραμέτρων.

Συμπεριλαμβάνονται ενδεικτικά κάποια από τα αρχεία εξόδου που χρησιμοποιήθηκαν για την εξαγωγή
των ανωτέρω συμπερασμάτων (στο φάκελο sample_outputs)